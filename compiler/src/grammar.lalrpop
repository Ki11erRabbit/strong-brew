use crate::parser::lexer::{Token, TokenLexer, SpannedLexerError};
use crate::ast::outer::*;
use either::Either;

grammar<'a>(input: &'a str);


extern {
    type Location = usize;
    type Error = SpannedLexerError;
    
    enum Token<'a> {
        "if" => Token::If,
        "else" => Token::Else,
        "match" => Token::Match,
        "fn" => Token::Fun,
        "return" => Token::Return,
        "break" => Token::Break,
        "continue" => Token::Continue,
        "struct" => Token::Struct,
        "enum" => Token::Enum,
        "let" => Token::Let,
        "mut" => Token::Mut,
        "const" => Token::Const,
        "import" => Token::Import,
        "module" => Token::Module,
        "pub" => Token::Pub,
        "extern" => Token::Extern,
        "i8" => Token::I8,
        "i16" => Token::I16,
        "i32" => Token::I32,
        "i64" => Token::I64,
        "int" => Token::Int,
        "nat" => Token::Nat,
        "f32" => Token::F32,
        "f64" => Token::F64,
        "char" => Token::Char,
        "bool" => Token::Bool,
        "True" => Token::True,
        "False" => Token::False,
        Int_lit => Token::IntLiteral(<&'a str>),
        Float_lit => Token::FloatLiteral(<&'a str>),
        Char_lit => Token::CharLiteral(<&'a str>),
        String_lit => Token::StringLiteral(<&'a str>),
        Identifier => Token::Identifier(<&'a str>),
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Multiply,
        "/" => Token::Divide,
        "%" => Token::Modulo,
        "!" => Token::Not,
        "||" => Token::Or,
        "&&" => Token::And,
        "==" => Token::Equals,
        "!=" => Token::NotEquals,
        "<=" => Token::LessThanOrEqual,
        ">=" => Token::GreaterThanOrEqual,
        "=" => Token::Assign,
        "++" => Token::Concat,
        "::" => Token::Scope,
        "{" => Token::BraceOpen,
        "}" => Token::BraceClose,
        "(" => Token::ParenOpen,
        ")" => Token::ParenClose,
        "[" => Token::BracketOpen,
        "]" => Token::BracketClose,
        "<" => Token::AngleOpen,
        ">" => Token::AngleClose,
        "," => Token::Comma,
        ":" => Token::Colon,
        "?" => Token::QMark,
        "|" => Token::Bar,
        "." => Token::Dot,
        "->" => Token::Arrow,
        Lb => Token::LineBreak,
        "comment" => Token::Comment,
        Indent => Token::Indent,
        "eof" => Token::Eof,
    }
}


pub File: File<'a> = {
    "module" <p:Path> Lb <decs:(Lb* <Decl> Lb)*> Lb* => File::new(p, decs),
};

pub Path: PathName<'a> = {
    <start: @L> <id:Identifier> <rest:("::" <Identifier>)*> <end: @R> => {
        /*let id = match id {
            Token::Identifier(id) => id,
            _ => unreachable!(),
        };*/
               
        let mut segments = vec![id];
        for r in rest.into_iter() {
            //match r {
                segments.push(id);
             //   _ => unreachable!(),
            //}
        }
        
        PathName::new(segments, start, end)
    },
};

pub Visibility: Visibility = {
    <vis:("pub")?> => {
        match vis {
            Some(_) => Visibility::Public,
            None => Visibility::Private,
        }
    },
};

pub Decl: TopLevelStatement<'a> = {
    <start: @L> "import" <p:Path> <end: @R> => Import::new(p, start, end),
    <f:Function> => f,
    <s:Struct> => s,
    <e:Enum> => e,
    <c:Const> => c,
};

pub Function: TopLevelStatement<'a> = {
    <r:RegularFunction> => r,
    <e:ExternFunction> => e,
};

pub RegularFunction: TopLevelStatement<'a> = {
    <start: @L> <vis:Visibility> "fn" <name:Path> <typaram:TypeParamList?> <params:ParamList> <ret:ReturnType> "=" <body:Block> <end: @R> => {
        let typaram = match typaram {
            Some(t) => t,
            None => Vec::new(),
        };
        Function::new(vis, name, typaram, params, ret, body, start, end)
    }
};

pub ExternFunction: TopLevelStatement<'a> = {
    <start: @L> <vis:Visibility> "extern" <lang:String_lit> "fn" <name:Path> <typaram:TypeParamList?> <params:ParamList> <ret:ReturnType> "=" <body:String_lit> <end: @R> => {
        let typaram = match typaram {
            Some(t) => t,
            None => Vec::new(),
        };
        Function::new_extern(vis, lang, name, typaram, params, ret, body, start, end)
    }
};

pub ParamList: Vec<Param<'a>> = {
    "(" <param:Param> <params:("," <Param>)*> ")" => {
        let mut v = vec![param];
        for p in params.into_iter() {
            v.push(p);
        }
        v
    },
    "(" ")" => {
        Vec::new()
    }
};

pub Param: Param<'a> = {
    <start: @L> <name:Identifier> ":" <ty:ExpressionType> <end: @R> => Param::new(false, name, ty, start, end),
    <start: @L> "?" <name:Identifier> ":" <ty:ExpressionType> <end: @R> => Param::new(true, name, ty, start, end),
};

pub ReturnType: Box<ExpressionType<'a>> = {
    <ty:("->" <ExpressionType>)?> => {
        match ty {
            Some(t) => Box::new(t),
            None => Box::new(ExpressionType::new(false, Expression::Literal(Literal::Unit))),
        }
    },
};



pub TypeParamList: Vec<GenericParam<'a>> = {
    "[" <param:TypeParam> <params:("," <TypeParam>)*> "]" => {
        let mut v = vec![param];
        for p in params.into_iter() {
            v.push(p);
        }
        v
    },
    "[" "]" => {
        Vec::new()
    },

};


pub TypeParam: GenericParam<'a> = {
    <start: @L> <name:Identifier> <end: @R> => GenericParam::new(name, Vec::new(), start, end),
    /*<start: @L> <name:Identifier> ":" <param:ExpressionType> <params:("|" <ExpressionType>)*>  <end: @R> => {
        let mut v = vec![param];
        for p in params.into_iter() {
            v.push(p);
        }
        GenericParam::new(name, v, start, end)
    },*/
};

pub Struct: TopLevelStatement<'a> = {
    <start: @L> <vis:Visibility> "struct" <name:Identifier> <typaram:TypeParamList> <fields:StructFields> <end: @R> => Struct::new(vis, name, typaram, fields, start, end),
};

pub StructFields: Vec<Field<'a>> = {
    "{" <field:Field> <fields:(Lb? "," <Field>)*> "}" => {
        let mut v = vec![field];
        for f in fields.into_iter() {
            v.push(f);
        }
        v
    },
    "{" "}" => Vec::new(),
};

pub Field: Field<'a> = {
    <start: @L> <vis:Visibility> <name:Identifier> ":" <ty:ExpressionType> <end: @R> => Field::new(vis, name, ty, start, end),
};

pub Enum: TopLevelStatement<'a> = {
    <start: @L> <vis:Visibility> "enum" <name:Identifier> <typaram:TypeParamList> <variants:EnumVariants> <end: @R> => Enum::new(vis, name, typaram, variants, start, end),
};

pub EnumVariants: Vec<Variant<'a>> = {
    "{" <variant:EnumVariant> <variants:(Lb? "," <EnumVariant>)*> "}" => {
        let mut v = vec![variant];
        for f in variants.into_iter() {
            v.push(f);
        }
        v
    },
    "{" "}" => Vec::new(),
};

pub EnumVariant: Variant<'a> = {
    <start: @L> <name:Identifier> <fields:EnumFields> <end: @R> => Variant::new(name, fields, start, end),
    <start: @L> <name:Identifier> <end: @R> => Variant::new(name, Vec::new(), start, end),
};


pub EnumFields: Vec<Field<'a>> = {
    "(" <field:Field> <fields:("," <Field>)*> ")" => {
        let mut v = vec![field];
        for f in fields.into_iter() {
            v.push(f);
        }
        v
    },
};


Const: TopLevelStatement<'a> = {
    <start: @L> <vis:Visibility> "const" <name:Path> ":" <ty:ExpressionType> "=" <val:Expr> <end: @R> => Const::new(vis, name, ty, val, start, end),
};


Block: Vec<Statement<'a>> = {
    "{" Lb? Indent? <expr:Statement> <exprs:(Lb Indent? <Statement>)*> Lb? "}" => {
        let mut v = vec![expr];
        for e in exprs.into_iter() {
            v.push(e);
        }
        v
    },
};

Statement: Statement<'a> = {
    <start: @L> "let" <id:Identifier> ":" <ty:ExpressionType> "=" <rhs:ExpressionType> <end: @R> => {
        Statement::new_let(id, ty, rhs, start, end)
    },
    <start: @L> "const" <id:Identifier> ":" <ty:ExpressionType> "=" <rhs:ExpressionType> <end: @R> => {
        Statement::new_const(id, ty, rhs, start, end)
    },
    <start: @L> <lhs:ExpressionTypeTrailing> "=" <rhs:ExpressionTypeTrailing> <end: @R> => {
        Statement::new_assignment(lhs, rhs, start, end)
    },
    <start: @L> <expr:ExpressionTypeTrailing> <end: @R> => {

        Statement::Expression(expr)
    },
};


ExpressionType: ExpressionType<'a> = {
    <start: @L> <expr:ExprType> <end: @R> => ExpressionType::new(false, expr),
    <start: @L> "mut" <expr:ExprType> <end: @R> => ExpressionType::new(true, expr),
};

ExpressionTypeTrailing: ExpressionType<'a> = {
    <start: @L> <expr:ExprTypeTrailing> <end: @R> => ExpressionType::new(false, expr),
    <start: @L> "mut" <expr:ExprTypeTrailing> <end: @R> => ExpressionType::new(true, expr),
};

TermExpr: Expression<'a> = {
    <id:Path> => Expression::Variable(id),
    <lit:Literal> => Expression::Literal(lit),
    <tuple:Tuple> => Expression::Literal(tuple),
    <start: @L> "-" <expr:TermExpr> <end: @R> => {
        let expr = Box::new(expr);
        Expression::new_unary(UnaryOperator::Neg, expr, start, end)
    },
    // TODO: break, continue
}


IndexExpr: Expression<'a> = {
    <term:TermExpr> => term,
    <start: @L> <lhs:IndexExpr> "[" <expr1:Expr> <exprs:("," <Expr>)*> "]" <end: @R> => {
        let lhs = Box::new(lhs);
        let mut v = vec![expr1];
        for e in exprs.into_iter() {
            v.push(e);
        }
        Expression::new_bracketed(lhs, v, start, end)
    },
    <start: @L> <obj:IndexExpr> "." <name:Identifier> <end: @R> => {
        let obj = Box::new(obj);
        Expression::new_member_access(obj, name, start, end)
    },
};

FactorExpr: Expression<'a> = {
    <term:IndexExpr> => term,
    <start: @L> <lhs:FactorExpr> "*" <rhs:IndexExpr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Mul, lhs, rhs, start, end)
    },
    <start: @L> <lhs:FactorExpr> "/" <rhs:IndexExpr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Div, lhs, rhs, start, end)
    },
    <start: @L> <lhs:FactorExpr> "%" <rhs:IndexExpr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Mod, lhs, rhs, start, end)
    },
};

SumExpr: Expression<'a> = {
    <factor:FactorExpr> => factor,
    <start: @L> <lhs:SumExpr> "+" <rhs:FactorExpr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Add, lhs, rhs, start, end)
    },
    <start: @L> <lhs:SumExpr> "-" <rhs:FactorExpr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Sub, lhs, rhs, start, end)
    },
};

CompareExpr: Expression<'a> = {
    <sum:SumExpr> => sum,
    <start: @L> <lhs:CompareExpr> "==" <rhs:SumExpr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Eq, lhs, rhs, start, end)
    },
    <start: @L> <lhs:CompareExpr> "!=" <rhs:SumExpr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Ne, lhs, rhs, start, end)
    },
    <start: @L> <lhs:CompareExpr> "<" <rhs:SumExpr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Lt, lhs, rhs, start, end)
    },
    <start: @L> <lhs:CompareExpr> "<=" <rhs:SumExpr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Le, lhs, rhs, start, end)
    },
    <start: @L> <lhs:CompareExpr> ">" <rhs:SumExpr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Gt, lhs, rhs, start, end)
    },
    <start: @L> <lhs:CompareExpr> ">=" <rhs:SumExpr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Ge, lhs, rhs, start, end)
    },
};

NotExpr: Expression<'a> = {
    <start: @L> "!" <expr:CompareExpr> <end: @R> => {
        let expr = Box::new(expr);
        Expression::new_unary(UnaryOperator::Not, expr, start, end)
    },
    <expr:CompareExpr> => expr,
};

ConjExpr: Expression<'a> = {
    <not:NotExpr> => not,
    <start: @L> <lhs:ConjExpr> "&&" <rhs:NotExpr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::And, lhs, rhs, start, end)
    },
};

DisjExpr: Expression<'a> = {
    <conj:ConjExpr> => conj,
    <start: @L> <lhs:DisjExpr> "||" <rhs:ConjExpr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Or, lhs, rhs, start, end)
    },
};

CallExpr: Expression<'a> = {
    <dis:DisjExpr> => dis,
    <call:Call> => Expression::Call(call),
};

TrailingExpr: Expression<'a> = {
    <call:CallExpr> => call,
};

ConditionalExpression: Expression<'a> = {
    <trail:TrailingExpr> => trail,
    <if_:IfExpr> => Expression::IfExpression(if_),
    <match_:MatchExpr> => Expression::MatchExpression(match_),
};

TryExpr: Expression<'a> = {
    <start: @L> <expr:ConditionalExpression> "?" <end: @R> => {
        let expr = Box::new(expr);
        Expression::new_unary(UnaryOperator::Try, expr, start, end)
    },
    <expr:ConditionalExpression> => expr,
};

ExprWithoutTrailing: Expression<'a> = {
    <trye:TryExpr> => trye,
    "return" <expr:ExprWithoutTrailing> => Expression::Return(Box::new(expr)),
    "(" <expr:ExprWithoutTrailing> ")" => Expression::Parenthesized(Box::new(expr)),
};

Expr: Expression<'a> = {
    <expr:ExprWithoutTrailing> => expr,
    <lambda:Closure> => lambda,
};


ExprType: Expression<'a> = {
    <expr:Expr> => expr,
    "i8" => Expression::Type(BuiltinType::I8),
    "i16" => Expression::Type(BuiltinType::I16),
    "i32" => Expression::Type(BuiltinType::I32),
    "i64" => Expression::Type(BuiltinType::I64),
    "int" => Expression::Type(BuiltinType::Int),
    "nat" => Expression::Type(BuiltinType::Nat),
    "f32" => Expression::Type(BuiltinType::F32),
    "f64" => Expression::Type(BuiltinType::F64),
    "char" => Expression::Type(BuiltinType::Char),
    "bool" => Expression::Type(BuiltinType::Bool),
};

ExprTypeTrailing: Expression<'a> = {
    <expr:Expr> => expr,
    <trail:Trailing> => trail,
    "i8" => Expression::Type(BuiltinType::I8),
    "i16" => Expression::Type(BuiltinType::I16),
    "i32" => Expression::Type(BuiltinType::I32),
    "i64" => Expression::Type(BuiltinType::I64),
    "int" => Expression::Type(BuiltinType::Int),
    "nat" => Expression::Type(BuiltinType::Nat),
    "f32" => Expression::Type(BuiltinType::F32),
    "f64" => Expression::Type(BuiltinType::F64),
    "char" => Expression::Type(BuiltinType::Char),
    "bool" => Expression::Type(BuiltinType::Bool),
};



IfExpr: IfExpression<'a> = {
    <start: @L> "if" <cond:ExprWithoutTrailing> <then:Block> <end: @R> => {
        let cond = Box::new(cond);
        IfExpression::new(cond, then, None, start, end)
    },
    <start: @L> "if" <cond:ExprWithoutTrailing> <then:Block> <else_:("else" <Block>)> <end: @R> => {
        let cond = Box::new(cond);
        let else_ = Either::Right(else_);
        IfExpression::new(cond, then, Some(else_), start, end)
    },
    <start: @L> "if" <cond:ExprWithoutTrailing> <then:Block> <else_:("else" <IfExpr>)> <end: @R> => {
        let cond = Box::new(cond);
        let else_ = Either::Left(Box::new(else_));
        IfExpression::new(cond, then, Some(else_), start, end)
    },
};

MatchExpr: MatchExpression<'a> = {
    <start: @L> "match" <expr:ExprWithoutTrailing> "{" Lb? <cases:(<MatchCase> Lb?)*> "}" <end: @R> => {
        MatchExpression::new(Box::new(expr), cases, start, end)
    },
};

MatchCase: MatchArm<'a> = {
    <start: @L> <pat:Pattern> "->" <expr:ExprWithoutTrailing> "," <end: @R> => MatchArm::new(pat, Either::Left(expr), start, end),
    <start: @L> <pat:Pattern> "->" <body:Block> <end: @R> => MatchArm::new(pat, Either::Right(body), start, end),
};

Pattern: Pattern<'a> = {
    <id:Identifier> => Pattern::Variable(id),
    <lit:Literal> => Pattern::Literal(lit),
    "(" <pat:Pattern> <pats:("," <Pattern>)+> ")" => {
        let mut v = vec![pat];
        for p in pats.into_iter() {
            v.push(p);
        }
        Pattern::Tuple(v)
    },
    <path:Path> <body:Constructor> => Pattern::Constructor { name: path, fields: body },
};

Constructor : Vec<Pattern<'a>> = {
    "(" <pat:Pattern> <pats:("," <Pattern>)*> ")" => {
        let mut v = vec![pat];
        for p in pats.into_iter() {
            v.push(p);
        }
        v
    },
    ("(" ")") => Vec::new(),
};

Literal: Literal<'a> = {
    <int:Int_lit> => Literal::Int(int),
    <float:Float_lit> => Literal::Float(float),
    <char:Char_lit> => Literal::Char(char),
    <string:String_lit> => Literal::String(string),
    "True" => Literal::Bool(true),
    "False" => Literal::Bool(false),
    "(" ")" => Literal::Unit,
};

Tuple: Literal<'a> = {
    "(" <expr:Expr> <exprs:("," <Expr>)+> ")" => {
        let mut v = vec![expr];
        for e in exprs.into_iter() {
            v.push(e);
        }
        Literal::Tuple(v)
    },
};

Closure: Expression<'a> = {
    <start: @L> <params:ClosureParamList> <ret:ReturnType> "=" <body:Block> <end: @R> => Closure::new(params, Some(ret), body, start, end),
    <start: @L> <body:Block> <end: @R> => Closure::new(Vec::new(), None, body, start, end),
    //<start: @L> <params:ClosureParamList> <ret:ReturnType> <body:Expr> <end: @R> => Closure::new(params, ret, vec![Statement::Expression(body)], start, end),

};


pub ClosureParamList: Vec<Param<'a>> = {
    "|" <param:Param> <params:("," <Param>)*> "|" => {
        let mut v = vec![param];
        for p in params.into_iter() {
            v.push(p);
        }
        v
    },
    "|" "|" => {
        Vec::new()
    }
};

Call: Call<'a> = {
    <start: @L> <callee:CallExpr> <args:ArgList> <end: @R> => {
        Call::new(Box::new(callee), Vec::new(), args, start, end)
    },
    //<start: @L> <callee:CallExpr> <typeargs:TypeArgList> <args:ArgList> <end: @R> => Call::new(Box::new(callee), typeargs, args, start, end),
};

Trailing: Expression<'a> = {
    <start: @L> <call:ExprWithoutTrailing> <lambdas:Closure+> <end: @R> => {
        Expression::TrailingLambdas(Box::new(call), lambdas, start, end)
    },
};


ArgList: Vec<CallArg<'a>> = {
    "(" <arg:CallArg> <args:("," <CallArg>)*> ")" => {
        let mut v = vec![arg];
        for a in args.into_iter() {
            v.push(a);
        }
        v
    },
    "(" ")" => Vec::new(),
};

CallArg: CallArg<'a> = {
    <start: @L> <name:(<Identifier> "=")?> <expr:Expr> <end: @R> => CallArg::new(name, expr, start, end),
};

TypeArgList: Vec<ExpressionType<'a>> = {
    "::" "[" <arg:ExpressionType> <args:("," <ExpressionType>)*> "]" => {
        let mut v = vec![arg];
        for a in args.into_iter() {
            v.push(a);
        }
        v
    },
    "::" "[" "]" => Vec::new(),
};


