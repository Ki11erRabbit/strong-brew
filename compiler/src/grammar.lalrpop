use crate::parser::lexer::{Token, TokenLexer, SpannedLexerError};
use crate::ast::outer::*;

grammar<'a>(input: &'a str);


extern {
    type Location = usize;
    type Error = SpannedLexerError;
    
    enum Token<'a> {
        "if" => Token::If,
        "else" => Token::Else,
        "fn" => Token::Fun,
        "return" => Token::Return,
        "break" => Token::Break,
        "continue" => Token::Continue,
        "struct" => Token::Struct,
        "enum" => Token::Enum,
        "let" => Token::Let,
        "mut" => Token::Mut,
        "const" => Token::Const,
        "import" => Token::Import,
        "module" => Token::Module,
        "pub" => Token::Pub,
        "extern" => Token::Extern,
        "i8" => Token::I8,
        "i16" => Token::I16,
        "i32" => Token::I32,
        "i64" => Token::I64,
        "int" => Token::Int,
        "nat" => Token::Nat,
        "f32" => Token::F32,
        "f64" => Token::F64,
        "char" => Token::Char,
        "bool" => Token::Bool,
        "True" => Token::True,
        "False" => Token::False,
        Int_lit => Token::IntLiteral(<&'a str>),
        Float_lit => Token::FloatLiteral(<&'a str>),
        Char_lit => Token::CharLiteral(<&'a str>),
        String_lit => Token::StringLiteral(<&'a str>),
        Identifier => Token::Identifier(<&'a str>),
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Multiply,
        "/" => Token::Divide,
        "%" => Token::Modulo,
        "!" => Token::Not,
        "||" => Token::Or,
        "&&" => Token::And,
        "==" => Token::Equals,
        "!=" => Token::NotEquals,
        "<=" => Token::LessThanOrEqual,
        ">=" => Token::GreaterThanOrEqual,
        "=" => Token::Assign,
        "++" => Token::Concat,
        "::" => Token::Scope,
        "{" => Token::BraceOpen,
        "}" => Token::BraceClose,
        "(" => Token::ParenOpen,
        ")" => Token::ParenClose,
        "[" => Token::BracketOpen,
        "]" => Token::BracketClose,
        "<" => Token::AngleOpen,
        ">" => Token::AngleClose,
        "," => Token::Comma,
        ":" => Token::Colon,
        "?" => Token::QMark,
        "|" => Token::Bar,
        "." => Token::Dot,
        "->" => Token::Arrow,
        Lb => Token::LineBreak,
        "comment" => Token::Comment,
        "eof" => Token::Eof,
    }
}


pub File: File<'a> = {
    "module" <p:Path> Lb <decs:(Lb* <Decl> Lb)*> Lb* => File::new(p, decs),
};

pub Path: PathName<'a> = {
    <start: @L> <id:Identifier> <rest:("::" <Identifier>)*> <end: @R> => {
        /*let id = match id {
            Token::Identifier(id) => id,
            _ => unreachable!(),
        };*/
               
        let mut segments = vec![id];
        for r in rest.into_iter() {
            //match r {
                segments.push(id);
             //   _ => unreachable!(),
            //}
        }
        
        PathName::new(segments, start, end)
    },
};

pub Visibility: Visibility = {
    <vis:("pub")?> => {
        match vis {
            Some(_) => Visibility::Public,
            None => Visibility::Private,
        }
    },
};

pub Decl: TopLevelStatement<'a> = {
    <start: @L> "import" <p:Path> <end: @R> => Import::new(p, start, end),
    <f:Function> => f,
    /*<s:Struct> => s,
    <e:Enum> => e,
    <c:Const> => c,*/
};

pub Function: TopLevelStatement<'a> = {
    <r:RegularFunction> => r,
    <e:ExternFunction> => e,
};

pub RegularFunction: TopLevelStatement<'a> = {
    <start: @L> <vis:Visibility> "fn" <name:Identifier> <typaram:TypeParamList> <params:ParamList> <ret:ReturnType> <body:Block> <end: @R> => Function::new(vis, name, typaram, params, ret, body, start, end),
};

pub ExternFunction: TopLevelStatement<'a> = {
    <start: @L> <vis:Visibility> "extern" <lang:String_lit> "fn" <name:Identifier> <typaram:TypeParamList> <params:ParamList> <ret:ReturnType> <body:String_lit> <end: @R> => Function::new_extern(vis, lang, name, typaram, params, ret, body, start, end),
};

pub ParamList: Vec<Param<'a>> = {
    "(" <params:(<Param> ("," <Param>)*)?> ")" => {
        match params {
            Some((p, ps)) => {
                let mut v = vec![p];
                for p in ps.into_iter() {
                    v.push(p.1);
                }
                v
            },
            None => Vec::new(),
        }
    },
};

pub Param: Param<'a> = {
    <start: @L> <name:Identifier> ":" <ty:Type> <end: @R> => Param::new(false, name, ty, start, end),
    <start: @L> "?" <name:Identifier> ":" <ty:Type> <end: @R> => Param::new(true, name, ty, start, end),
};

pub ReturnType: Type<'a> = {
    <ty:("->" <Type>)?> => {
        match ty {
            Some(t) => t,
            None => Type::Unit,
        }
    },
};


pub Type: Type<'a> = {
    <m:("mut")?> <ty:RawType> => {
        match m {
            Some(_) => Type::new(true, ty),
            None => Type::new(false, ty),
        }
    },
};

pub RawType: RawType<'a> = {
    "i8" => TypeRaw::new_builtin(BuiltinType::I8),
    "i16" => TypeRaw::new_builtin(BuiltinType::I16),
    "i32" => TypeRaw::new_builtin(BuiltinType::I32),
    "i64" => TypeRaw::new_builtin(BuiltinType::I64),
    "int" => TypeRaw::new_builtin(BuiltinType::Int),
    "nat" => TypeRaw::new_builtin(BuiltinType::Nat),
    "f32" => TypeRaw::new_builtin(BuiltinType::F32),
    "f64" => TypeRaw::new_builtin(BuiltinType::F64),
    "char" => TypeRaw::new_builtin(BuiltinType::Char),
    "bool" => TypeRaw::new_builtin(BuiltinType::Bool),
    "(" ")" => TypeRaw::new_builtin(BuiltinType::Unit),
    "!" => TypeRaw::new_builtin(BuiltinType::Never),
    <start: @L> <p:Path> <end: @R> => TypeRaw::new_simple(p, start, end),
    <start: @L> <p:Path> "<" <arg:Type> <args:("," Type)*> ">" <end: @R> => {
        let mut v = vec![arg];
        for a in args.into_iter() {
            v.push(a.1);
        }
        TypeRaw::new_generic(p, v, start, end)
    },
    // TODO: Do expression type
};

pub TypeParamList: Vec<GenericParam<'a>> = {
    <params:("<" <TypeParam> ("," <TypeParam>)* ">")?> => {
        params.unwrap_or(Vec::new())
    },

};


pub TypeParam: GenericParam<'a> = {
    <start: @L> <name:Identifier> <end: @R> => GenericParam::new(name, Vec::new(), start, end),
    <start: @L> <name:Identifier> ":" <params:(<Type> ("+" <Type>)* )> <end: @R> => GenericParam::new_with_type(name, params, start, end),
};

pub Struct: TopLevelStatement<'a> = {
    <start: @L> <vis:Visibility> "struct" <name:Identifier> <typaram:TypeParamList> <fields:StructFields> <end: @R> => Struct::new(vis, name, typaram, fields, start, end),
};

pub StructFields: Vec<Field<'a>> = {
    "{" <fields:(<Field> (Lb? "," <Field>)*)?> "}" => {
        match fields {
            Some((f, fs)) => {
                let mut v = vec![f];
                for f in fs.into_iter() {
                    v.push(f.1);
                }
                v
            },
            None => Vec::new(),
        }
    },
};

pub Field: Field<'a> = {
    <start: @L> <vis:Visibility> <name:Identifier> ":" <ty:Type> <end: @R> => StructField::new(vis, name, ty, start, end),
};

pub Enum: TopLevelStatement<'a> = {
    <start: @L> <vis:Visibility> "enum" <name:Identifier> <typaram:TypeParamList> <variants:EnumVariants> <end: @R> => Enum::new(vis, name, typaram, variants, start, end),
};

pub EnumVariants: Vec<Variant<'a>> = {
    "{" <variants:(<EnumVariant> (Lb? "," <EnumVariant>)*)?> "}" => {
        match variants {
            Some((v, vs)) => {
                let mut v = vec![v];
                for v in vs.into_iter() {
                    v.push(v.1);
                }
                v
            },
            None => Vec::new(),
        }
    },
};

pub EnumVariant: Variant<'a> = {
    <start: @L> <name:Identifier> <fields:EnumFields> <end: @R> => EnumVariant::new(name, fields, start, end),
};


pub EnumFields: Vec<Field<'a>> = {
    "(" <fields:(<Field> ("," <Field>)*)?> ")" => {
        match fields {
            Some((f, fs)) => {
                let mut v = vec![f];
                for f in fs.into_iter() {
                    v.push(f.1);
                }
                v
            },
            None => Vec::new(),
        }
    },
};


Const: TopLevelStatement<'a> = {
    <start: @L> <vis:Visibility> "const" <name:Identifier> ":" <ty:Type> "=" <val:Expr> <end: @R> => Const::new(vis, name, ty, val, start, end),
};


Block: Expression<'a> = {
    "{" Lb? <expr:(<Expr> (Lb <Expr>)*)> Lb? "}" => {
        expr
    },
};

/*ExprSequence: Expr<'a> = {
    <expr:(<Expr> (Lb <Expr>)*)> => {
        Expression::Sequence(expr)
    }
};*/

Expr: Expression<'a> = {
    #[precedence(level="0")]
    Identifier => Expression::Identifier(id),
    /*"(" <expr:Expr> ")" => Expression::Parenthesized(Box::new(expr)),
    // TODO: Add literals
    #[precedence(level="2")]
    // TODO: Function call
    <start: @L> <lhs:Expr> "[" <index:Expr> "]" <end: @R> => {
        let lhs = Box::new(lhs);
        let index = Box::new(index);
        Expression::new_binary(BinaryOperator::Index, lhs, index, start, end)
    }
    #[precedence(level="3")]
    <start: @L> <expr:Expr> "?" <end: @R> => {
    let expr = Box::new(expr);
        Expression::new_unary(UnaryOperator::Try, expr, start, end)
    },
    #[precedence(level="4")]
    <start: @L> "-" <expr:Expr> <end: @R> => {
        let expr = Box::new(expr);
        Expression::new_unary(UnaryOperator::Neg, expr, start, end)
    },
    <start: @L> "!" <expr:Expr> <end: @R> => {
        let expr = Box::new(expr);
        Expression::new_unary(UnaryOperator::Not, expr, start, end)
    },
    #[precedence(level="5")] #[assoc(side="left")]
    <start: @L> <lhs:Expr> "*" <rhs:Expr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Mul, lhs, rhs, start, end)
    },
    <start: @L> <lhs:Expr> "/" <rhs:Expr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Div, lhs, rhs, start, end)
    },
    <start: @L> <lhs:Expr> "%" <rhs:Expr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Mod, lhs, rhs, start, end)
    },
    #[precedence(level="6")] #[assoc(side="left")]
    <start: @L> <lhs:Expr> "+" <rhs:Expr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Add, lhs, rhs, start, end)
    },
    <start: @L> <lhs:Expr> "-" <rhs:Expr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Sub, lhs, rhs, start, end)
    },
    #[precedence(level="7")] #[assoc(side="left")]
    <start: @L> <lhs:Expr> "==" <rhs:Expr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Eq, lhs, rhs, start, end)
    },
    <start: @L> <lhs:Expr> "!=" <rhs:Expr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Neq, lhs, rhs, start, end)
    },
    <start: @L> <lhs:Expr> "<" <rhs:Expr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Lt, lhs, rhs, start, end)
    },
    <start: @L> <lhs:Expr> "<=" <rhs:Expr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Le, lhs, rhs, start, end)
    },
    <start: @L> <lhs:Expr> ">" <rhs:Expr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Gt, lhs, rhs, start, end)
    },
    <start: @L> <lhs:Expr> ">=" <rhs:Expr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Ge, lhs, rhs, start, end)
    },
    #[precedence(level="8")] #[assoc(side="left")]
    <start: @L> <lhs:Expr> "&&" <rhs:Expr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::And, lhs, rhs, start, end)
    },
    #[precedence(level="9")] #[assoc(side="left")]
    <start: @L> <lhs:Expr> "||" <rhs:Expr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_binary(BinaryOperator::Or, lhs, rhs, start, end)
    },
    #[precedence(level="10")] #[assoc(side="right")]
    <start: @L> <lhs:Expr> "=" <rhs:Expr> <end: @R> => {
        let lhs = Box::new(lhs);
        let rhs = Box::new(rhs);
        Expression::new_assignment(lhs, rhs, start, end)
    },
    <start: @L> "let" <id:Identifier> ":" <ty:Type> "=" <rhs:Expr> <end: @R> => {
        let rhs = Box::new(rhs);
        Expression::new_let(id, ty, rhs, start, end)
    }
    <start: @L> "const" <id:Identifier> ":" <ty:Type> "=" <rhs:Expr> <end: @R> => {
        let rhs = Box::new(rhs);
        Expression::new_const(id, ty, rhs, start, end)
    }
    #[precedence(level="11")]
    "return" <expr:Expr> => Expression::new_return(expr),*/
    // TODO: break, continue, closures
};
